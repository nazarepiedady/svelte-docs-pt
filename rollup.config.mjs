import fs from 'node:fs';
import { createRequire } from 'node:module';
import replace from '@rollup/plugin-replace';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import sucrase from '@rollup/plugin-sucrase';
import typescript from '@rollup/plugin-typescript';

const require = createRequire(import.meta.url);
const pkg = JSON.parse(fs.readFileSync('package.json', 'utf-8'));

const is_publish = !!process.env.PUBLISH;

const ts_plugin = is_publish
	? typescript({
			typescript: require('typescript'),
			paths: {
				'svelte/*': ['./src/runtime/*']
			}
	  })
	: sucrase({
			transforms: ['typescript']
	  });

fs.writeFileSync(
	`./compiler.d.ts`,
	`export { compile, parse, preprocess, walk, VERSION } from './types/compiler/index.js';`
);

const runtime_entrypoints = Object.fromEntries(
	fs
		.readdirSync('src/runtime', { withFileTypes: true })
		.filter((dirent) => dirent.isDirectory())
		.map((dirent) => [dirent.name, `src/runtime/${dirent.name}/index.ts`])
);

/**
 * @type {import("rollup").RollupOptions[]}
 */
export default [
	{
		input: {
			...runtime_entrypoints,
			index: 'src/runtime/index.ts',
			ssr: 'src/runtime/ssr.ts'
		},
		output: ['es', 'cjs'].map(
			/** @returns {import('rollup').OutputOptions} */
			(format) => {
				const ext = format === 'es' ? 'mjs' : 'js';
				return {
					entryFileNames: (entry) => {
						if (entry.isEntry) {
							if (entry.name === 'index') return `index.${ext}`;
							else if (entry.name === 'ssr') return `ssr.${ext}`;

							return `${entry.name}/index.${ext}`;
						}
					},
					chunkFileNames: `internal/[name]-[hash].${ext}`,
					format,
					minifyInternalExports: false,
					dir: '.',
				};
			}
		),
		plugins: [
			replace({
				preventAssignment: true,
				values: {
					__VERSION__: pkg.version,
				},
			}),
			ts_plugin,
			{
				writeBundle(options, bundle) {
					if (options.format !== 'es') return;

					for (const entry of Object.values(bundle)) {
						const dir = entry.name;
						if (!entry.isEntry || !runtime_entrypoints[dir]) continue;

						if (dir === 'internal') {
							const mod = bundle[`internal/index.mjs`];
							if (mod) {
								fs.writeFileSync(
									'src/compiler/compile/internal_exports.ts',
									`// This file is automatically generated\n` +
										`export default new Set(${JSON.stringify(mod.exports)});`
								);
							}
						}

						fs.writeFileSync(
							`${dir}/index.d.ts`,
							`export * from '../types/runtime/${dir}/index.js';`
						);
					}
				}
			}
		]
	},
	/* compiler.js */
	{
		input: 'src/compiler/index.ts',
		plugins: [
			replace({
				preventAssignment: true,
				values: {
					__VERSION__: pkg.version,
					'process.env.NODE_DEBUG': false // appears inside the util package
				},
			}),
			{
				resolveId(id) {
					// util is a built-in module in Node.js, but we want a self-contained compiler bundle
					// that also works in the browser, so we load its polyfill instead
					if (id === 'util') {
						return require.resolve('./node_modules/util'); // just 'utils' would resolve this to the built-in module
					}
				},
			},
			resolve(),
			commonjs({
				include: ['node_modules/**']
			}),
			json(),
			ts_plugin
		],
		output: [
			{
				file: 'compiler.js',
				format: is_publish ? 'umd' : 'cjs',
				name: 'svelte',
				sourcemap: true,
			},
			{
				file: 'compiler.mjs',
				format: 'esm',
				name: 'svelte',
				sourcemap: true,
			}
		],
		external: is_publish
			? []
			: (id) =>
					id === 'acorn' || id === 'magic-string' || id.startsWith('css-tree')
	}
];
